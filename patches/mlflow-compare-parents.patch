--- /dev/null	2026-02-03 20:17:21.722131884 +0100
+++ .venv/lib/python3.12/site-packages/mlflow/server/__init__.py	2026-02-03 21:56:59.335347124 +0100
@@ -0,0 +1,1309 @@
+import importlib
+import importlib.metadata
+import logging
+import os
+import shlex
+import sys
+import tempfile
+import textwrap
+import types
+import warnings
+
+_logger = logging.getLogger("mlflow.server")
+
+from flask import Flask, Response, send_from_directory
+from packaging.version import Version
+
+from mlflow.environment_variables import (
+    _MLFLOW_SGI_NAME,
+    MLFLOW_FLASK_SERVER_SECRET_KEY,
+    MLFLOW_SERVER_ENABLE_JOB_EXECUTION,
+)
+from mlflow.exceptions import MlflowException
+from mlflow.server import handlers
+from mlflow.server.constants import (
+    ARTIFACT_ROOT_ENV_VAR,
+    ARTIFACTS_DESTINATION_ENV_VAR,
+    ARTIFACTS_ONLY_ENV_VAR,
+    BACKEND_STORE_URI_ENV_VAR,
+    HUEY_STORAGE_PATH_ENV_VAR,
+    PROMETHEUS_EXPORTER_ENV_VAR,
+    REGISTRY_STORE_URI_ENV_VAR,
+    SECRETS_CACHE_MAX_SIZE_ENV_VAR,
+    SECRETS_CACHE_TTL_ENV_VAR,
+    SERVE_ARTIFACTS_ENV_VAR,
+)
+from mlflow.server.handlers import (
+    STATIC_PREFIX_ENV_VAR,
+    _add_static_prefix,
+    _search_datasets_handler,
+    create_promptlab_run_handler,
+    gateway_proxy_handler,
+    get_artifact_handler,
+    get_logged_model_artifact_handler,
+    get_metric_history_bulk_handler,
+    get_metric_history_bulk_interval_handler,
+    get_model_version_artifact_handler,
+    get_trace_artifact_handler,
+    get_ui_telemetry_handler,
+    post_ui_telemetry_handler,
+    upload_artifact_handler,
+)
+from mlflow.utils.os import is_windows
+from mlflow.utils.plugins import get_entry_points
+from mlflow.utils.process import _exec_cmd
+from mlflow.version import VERSION
+
+REL_STATIC_DIR = "js/build"
+
+app = Flask(__name__, static_folder=REL_STATIC_DIR)
+IS_FLASK_V1 = Version(importlib.metadata.version("flask")) < Version("2.0")
+
+is_running_as_server = (
+    "gunicorn" in sys.modules
+    or "uvicorn" in sys.modules
+    or "waitress" in sys.modules
+    or os.getenv(BACKEND_STORE_URI_ENV_VAR)
+    or os.getenv(SERVE_ARTIFACTS_ENV_VAR)
+)
+
+if is_running_as_server:
+    from mlflow.server import security
+
+    security.init_security_middleware(app)
+
+for http_path, handler, methods in handlers.get_endpoints():
+    app.add_url_rule(http_path, handler.__name__, handler, methods=methods)
+
+if os.getenv(PROMETHEUS_EXPORTER_ENV_VAR):
+    from mlflow.server.prometheus_exporter import activate_prometheus_exporter
+
+    prometheus_metrics_path = os.getenv(PROMETHEUS_EXPORTER_ENV_VAR)
+    if not os.path.exists(prometheus_metrics_path):
+        os.makedirs(prometheus_metrics_path)
+    activate_prometheus_exporter(app)
+
+
+# Provide a health check endpoint to ensure the application is responsive
+@app.route(_add_static_prefix("/health"))
+def health():
+    return "OK", 200
+
+
+# Provide an endpoint to query the version of mlflow running on the server
+@app.route(_add_static_prefix("/version"))
+def version():
+    return VERSION, 200
+
+
+# Serve the "get-artifact" route.
+@app.route(_add_static_prefix("/get-artifact"))
+def serve_artifacts():
+    return get_artifact_handler()
+
+
+# Serve the "model-versions/get-artifact" route.
+@app.route(_add_static_prefix("/model-versions/get-artifact"))
+def serve_model_version_artifact():
+    return get_model_version_artifact_handler()
+
+
+# Serve the "metrics/get-history-bulk" route.
+@app.route(_add_static_prefix("/ajax-api/2.0/mlflow/metrics/get-history-bulk"))
+def serve_get_metric_history_bulk():
+    return get_metric_history_bulk_handler()
+
+
+# Serve the "metrics/get-history-bulk-interval" route.
+@app.route(_add_static_prefix("/ajax-api/2.0/mlflow/metrics/get-history-bulk-interval"))
+def serve_get_metric_history_bulk_interval():
+    return get_metric_history_bulk_interval_handler()
+
+
+# Serve the "experiments/search-datasets" route.
+@app.route(_add_static_prefix("/ajax-api/2.0/mlflow/experiments/search-datasets"), methods=["POST"])
+def serve_search_datasets():
+    return _search_datasets_handler()
+
+
+# Serve the "runs/create-promptlab-run" route.
+@app.route(_add_static_prefix("/ajax-api/2.0/mlflow/runs/create-promptlab-run"), methods=["POST"])
+def serve_create_promptlab_run():
+    return create_promptlab_run_handler()
+
+
+@app.route(_add_static_prefix("/ajax-api/2.0/mlflow/gateway-proxy"), methods=["POST", "GET"])
+def serve_gateway_proxy():
+    return gateway_proxy_handler()
+
+
+@app.route(_add_static_prefix("/ajax-api/2.0/mlflow/upload-artifact"), methods=["POST"])
+def serve_upload_artifact():
+    return upload_artifact_handler()
+
+
+# Serve the "/get-trace-artifact" route to allow frontend to fetch trace artifacts
+# and render them in the Trace UI. The request body should contain the request_id
+# of the trace.
+@app.route(_add_static_prefix("/ajax-api/2.0/mlflow/get-trace-artifact"), methods=["GET"])
+def serve_get_trace_artifact():
+    return get_trace_artifact_handler()
+
+
+@app.route(
+    _add_static_prefix("/ajax-api/2.0/mlflow/logged-models/<model_id>/artifacts/files"),
+    methods=["GET"],
+)
+def serve_get_logged_model_artifact(model_id: str):
+    return get_logged_model_artifact_handler(model_id)
+
+
+@app.route(_add_static_prefix("/ajax-api/3.0/mlflow/ui-telemetry"), methods=["GET"])
+def serve_get_ui_telemetry():
+    return get_ui_telemetry_handler()
+
+
+@app.route(_add_static_prefix("/ajax-api/3.0/mlflow/ui-telemetry"), methods=["POST"])
+def serve_post_ui_telemetry():
+    return post_ui_telemetry_handler()
+
+
+@app.route(_add_static_prefix("/compare-parents"))
+def serve_compare_parents():
+    html = textwrap.dedent(
+        """
+        <!doctype html>
+        <html lang="en">
+          <head>
+            <meta charset="utf-8" />
+            <meta name="viewport" content="width=device-width, initial-scale=1" />
+            <title>MLflow Parent Run Compare</title>
+            <style>
+              :root {
+                color-scheme: light dark;
+                --bg: #0e1116;
+                --panel: #151a21;
+                --muted: #9aa4b2;
+                --text: #e6e9ef;
+                --accent-a: #4d9de0;
+                --accent-b: #f07167;
+                --grid: rgba(255, 255, 255, 0.08);
+              }
+              body {
+                margin: 0;
+                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
+                background: var(--bg);
+                color: var(--text);
+              }
+              header {
+                padding: 16px 20px;
+                border-bottom: 1px solid var(--grid);
+                background: linear-gradient(180deg, #12161d, #0e1116);
+              }
+              h1 {
+                margin: 0 0 6px 0;
+                font-size: 18px;
+                font-weight: 600;
+              }
+              .subtle {
+                color: var(--muted);
+                font-size: 13px;
+              }
+              .container {
+                padding: 16px 20px 28px 20px;
+                display: grid;
+                gap: 16px;
+              }
+              .panel {
+                background: var(--panel);
+                border: 1px solid var(--grid);
+                border-radius: 10px;
+                padding: 12px;
+              }
+              .controls {
+                display: grid;
+                gap: 10px;
+                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
+                align-items: end;
+              }
+              label {
+                display: block;
+                font-size: 12px;
+                color: var(--muted);
+                margin-bottom: 6px;
+              }
+              input {
+                width: 100%;
+                box-sizing: border-box;
+                padding: 8px 10px;
+                border-radius: 6px;
+                border: 1px solid var(--grid);
+                background: #0f1319;
+                color: var(--text);
+                font-size: 13px;
+              }
+              button {
+                padding: 9px 12px;
+                border-radius: 6px;
+                border: 1px solid var(--grid);
+                background: #1b2230;
+                color: var(--text);
+                cursor: pointer;
+                font-size: 13px;
+                font-weight: 600;
+              }
+              button:hover {
+                background: #222b3d;
+              }
+              .legend {
+                display: flex;
+                gap: 16px;
+                align-items: center;
+                font-size: 12px;
+                color: var(--muted);
+              }
+              .tooltip {
+                position: fixed;
+                pointer-events: auto;
+                z-index: 9999;
+                background: #0f1319;
+                border: 1px solid var(--grid);
+                border-radius: 8px;
+                padding: 10px;
+                max-width: 560px;
+                max-height: 420px;
+                overflow: auto;
+                overscroll-behavior: contain;
+                box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
+                display: none;
+              }
+              .sidebar {
+                position: fixed;
+                right: 16px;
+                top: 16px;
+                bottom: 16px;
+                width: 520px;
+                background: #0f1319;
+                border: 1px solid var(--grid);
+                border-radius: 10px;
+                padding: 12px;
+                overflow: auto;
+                display: none;
+                z-index: 10000;
+                box-shadow: 0 16px 36px rgba(0, 0, 0, 0.45);
+                font-size: 13px;
+                min-width: 520px;
+                max-width: 90vw;
+              }
+              .sidebar-resize {
+                position: absolute;
+                left: -6px;
+                top: 0;
+                bottom: 0;
+                width: 12px;
+                cursor: ew-resize;
+                background: rgba(255, 255, 255, 0.04);
+                border-left: 1px solid rgba(255, 255, 255, 0.08);
+                z-index: 1;
+                pointer-events: auto;
+              }
+              .sidebar h3 {
+                margin: 0 0 8px 0;
+                font-size: 14px;
+                font-weight: 600;
+              }
+              .sidebar .cols {
+                display: grid;
+                grid-template-columns: 1fr 1fr;
+                gap: 10px;
+                margin-bottom: 12px;
+              }
+              .sidebar .card {
+                border: 1px solid var(--grid);
+                border-radius: 8px;
+                padding: 8px;
+                background: #10151d;
+              }
+              .sidebar .card h4 {
+                margin: 0 0 6px 0;
+                font-size: 13px;
+                font-weight: 600;
+                color: var(--text);
+              }
+              .kv {
+                font-size: 12px;
+                color: var(--muted);
+                line-height: 1.5;
+              }
+              .kv b {
+                color: var(--text);
+                font-weight: 600;
+              }
+              details {
+                margin-top: 10px;
+                border: 1px solid var(--grid);
+                border-radius: 8px;
+                padding: 6px 8px;
+                background: #0f1319;
+              }
+              details summary {
+                cursor: pointer;
+                color: var(--muted);
+                font-size: 11px;
+                user-select: none;
+              }
+              .sidebar .close {
+                position: absolute;
+                top: 10px;
+                right: 10px;
+                border: 1px solid var(--grid);
+                background: #141923;
+                color: var(--text);
+                border-radius: 6px;
+                padding: 4px 8px;
+                cursor: pointer;
+                font-size: 12px;
+              }
+              .tooltip h4 {
+                margin: 0 0 6px 0;
+                font-size: 12px;
+                font-weight: 600;
+                color: var(--text);
+              }
+              .tooltip pre {
+                margin: 0;
+                white-space: pre-wrap;
+                word-break: break-word;
+                color: var(--muted);
+                font-size: 11px;
+              }
+              .dot {
+                width: 10px;
+                height: 10px;
+                border-radius: 50%;
+                display: inline-block;
+                margin-right: 6px;
+              }
+              canvas {
+                width: 100%;
+                height: 240px;
+                background: #0f1319;
+                border-radius: 8px;
+              }
+              table {
+                width: 100%;
+                border-collapse: collapse;
+                font-size: 12px;
+              }
+              th, td {
+                border-bottom: 1px solid var(--grid);
+                padding: 6px 8px;
+                text-align: left;
+                vertical-align: top;
+              }
+              th {
+                color: var(--muted);
+                font-weight: 600;
+              }
+              .muted {
+                color: var(--muted);
+              }
+            </style>
+          </head>
+          <body>
+            <header>
+              <h1>Parent Run Comparison</h1>
+              <div class="subtle">Grouped child runs, colored by parent run</div>
+            </header>
+            <div class="container">
+              <div class="panel">
+                <div class="controls">
+                  <div>
+                    <label>Experiment ID</label>
+                    <input id="experimentId" placeholder="e.g. 2" />
+                  </div>
+                  <div>
+                    <label>Parent Run A</label>
+                    <input id="parentA" placeholder="parent run id A" />
+                  </div>
+                  <div>
+                    <label>Parent Run B</label>
+                    <input id="parentB" placeholder="parent run id B" />
+                  </div>
+                  <div>
+                    <label>Metric 1</label>
+                    <input id="metric1" placeholder="Completeness_GEval" />
+                  </div>
+                  <div>
+                    <label>Metric 2</label>
+                    <input id="metric2" placeholder="Grounding_GEval" />
+                  </div>
+                  <div>
+                    <label>Metric 3</label>
+                    <input id="metric3" placeholder="Reasoning_GEval" />
+                  </div>
+                  <button id="loadBtn">Load</button>
+                </div>
+              </div>
+              <div class="panel">
+                <div class="legend">
+                  <span><span class="dot" style="background: var(--accent-a);"></span><span id="legendA">Parent A</span></span>
+                  <span><span class="dot" style="background: var(--accent-b);"></span><span id="legendB">Parent B</span></span>
+                </div>
+              </div>
+              <div class="panel">
+                <div class="subtle" id="plotTitle1">Metric 1</div>
+                <canvas id="plot1" width="1200" height="300"></canvas>
+              </div>
+              <div class="panel">
+                <div class="subtle" id="plotTitle2">Metric 2</div>
+                <canvas id="plot2" width="1200" height="300"></canvas>
+              </div>
+              <div class="panel">
+                <div class="subtle" id="plotTitle3">Metric 3</div>
+                <canvas id="plot3" width="1200" height="300"></canvas>
+              </div>
+              <div class="panel">
+                <div class="subtle">Grouped Table (by question_id)</div>
+                <div style="overflow:auto; max-height: 360px;">
+                  <table id="resultsTable">
+                    <thead>
+                      <tr>
+                        <th>question_id</th>
+                        <th>Parent A run</th>
+                        <th>Parent A metrics</th>
+                        <th>Parent B run</th>
+                        <th>Parent B metrics</th>
+                      </tr>
+                    </thead>
+                    <tbody></tbody>
+                  </table>
+                </div>
+              </div>
+            </div>
+            <div class="tooltip" id="tooltip"></div>
+            <div class="sidebar" id="sidebar">
+              <div class="sidebar-resize" id="sidebarResize"></div>
+              <button class="close" id="sidebarClose">Close</button>
+              <h3 id="sidebarTitle">Details</h3>
+              <div id="sidebarContent"></div>
+            </div>
+            <script>
+              const defaultMetrics = {
+                metric1: "Completeness_GEval",
+                metric2: "Grounding_GEval",
+                metric3: "Reasoning_GEval",
+              };
+
+              function getParam(name, fallback = "") {
+                const params = new URLSearchParams(window.location.search);
+                return params.get(name) || fallback;
+              }
+
+              function setInputsFromUrl() {
+                document.getElementById("experimentId").value = getParam("experiment_id");
+                document.getElementById("parentA").value = getParam("parent_a");
+                document.getElementById("parentB").value = getParam("parent_b");
+                document.getElementById("metric1").value = getParam("metric1", defaultMetrics.metric1);
+                document.getElementById("metric2").value = getParam("metric2", defaultMetrics.metric2);
+                document.getElementById("metric3").value = getParam("metric3", defaultMetrics.metric3);
+              }
+
+              function updateUrlFromInputs() {
+                const params = new URLSearchParams();
+                params.set("experiment_id", document.getElementById("experimentId").value.trim());
+                params.set("parent_a", document.getElementById("parentA").value.trim());
+                params.set("parent_b", document.getElementById("parentB").value.trim());
+                params.set("metric1", document.getElementById("metric1").value.trim());
+                params.set("metric2", document.getElementById("metric2").value.trim());
+                params.set("metric3", document.getElementById("metric3").value.trim());
+                window.history.replaceState({}, "", `${window.location.pathname}?${params.toString()}`);
+              }
+
+              async function searchRuns(experimentId, parentRunId) {
+                const body = {
+                  experiment_ids: [experimentId],
+                  filter: `tags.mlflow.parentRunId = '${parentRunId}'`,
+                  max_results: 10000,
+                };
+                const res = await fetch("/ajax-api/2.0/mlflow/runs/search", {
+                  method: "POST",
+                  headers: { "Content-Type": "application/json" },
+                  body: JSON.stringify(body),
+                });
+                const data = await res.json();
+                return data.runs || [];
+              }
+
+              async function resolveParentRunId(experimentId, parentInput) {
+                if (!parentInput) return "";
+                const body = {
+                  experiment_ids: [experimentId],
+                  filter: `attributes.run_name = '${parentInput}'`,
+                  max_results: 1,
+                };
+                const res = await fetch("/ajax-api/2.0/mlflow/runs/search", {
+                  method: "POST",
+                  headers: { "Content-Type": "application/json" },
+                  body: JSON.stringify(body),
+                });
+                const data = await res.json();
+                const run = (data.runs || [])[0];
+                return run ? (run.info.run_id || run.info.run_uuid) : "";
+              }
+
+              async function getRunById(experimentId, runId) {
+                if (!runId) return null;
+                const body = {
+                  experiment_ids: [experimentId],
+                  filter: `attributes.run_id = '${runId}'`,
+                  max_results: 1,
+                };
+                const res = await fetch("/ajax-api/2.0/mlflow/runs/search", {
+                  method: "POST",
+                  headers: { "Content-Type": "application/json" },
+                  body: JSON.stringify(body),
+                });
+                const data = await res.json();
+                return (data.runs || [])[0] || null;
+              }
+
+              function parseRun(run) {
+                const params = (run.data.params || []).reduce((acc, p) => {
+                  acc[p.key] = p.value;
+                  return acc;
+                }, {});
+                const metrics = (run.data.metrics || []).reduce((acc, m) => {
+                  acc[m.key] = m.value;
+                  return acc;
+                }, {});
+                const tags = (run.data.tags || []).reduce((acc, t) => {
+                  acc[t.key] = t.value;
+                  return acc;
+                }, {});
+                return {
+                  runId: run.info.run_id || run.info.run_uuid,
+                  runName: run.info.run_name,
+                  params,
+                  metrics,
+                  tags,
+                };
+              }
+
+              function numericOrNull(value) {
+                if (value === undefined || value === null) return null;
+                const n = Number(value);
+                return Number.isFinite(n) ? n : null;
+              }
+
+              function normalizeQuestionId(value) {
+                if (value === undefined || value === null) return null;
+                const num = numericOrNull(value);
+                if (num !== null) return num;
+                return String(value);
+              }
+
+              function buildPoints(runs, parentKey, metricKey) {
+                return runs
+                  .map((r) => {
+                    const qid = normalizeQuestionId(r.params.question_id);
+                    const y = numericOrNull(r.metrics[metricKey]);
+                    if (qid === null || y === null) return null;
+                    return { parentKey, qid, y, runName: r.runName || r.runId };
+                  })
+                  .filter(Boolean);
+              }
+
+              function resizeCanvas(canvas, height) {
+                const cssWidth = canvas.clientWidth || 800;
+                const ratio = window.devicePixelRatio || 1;
+                canvas.width = Math.floor(cssWidth * ratio);
+                canvas.height = Math.floor(height * ratio);
+                const ctx = canvas.getContext("2d");
+                ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
+              }
+
+              function renderRunInfo(label, run, metricKey) {
+                if (!run) {
+                  return `${label}: n/a`;
+                }
+                const info = {
+                  run_name: run.runName,
+                  run_id: run.runId,
+                  question_id: run.params.question_id,
+                  metric: metricKey,
+                  metric_value: run.metrics[metricKey],
+                  params: run.params,
+                  metrics: run.metrics,
+                  tags: run.tags,
+                };
+                return `${label}:\n${JSON.stringify(info, null, 2)}`;
+              }
+
+              function renderTooltipContent(qid, metricKey, row, parentLabels) {
+                const aLabel = parentLabels.a || "Parent A";
+                const bLabel = parentLabels.b || "Parent B";
+                return [
+                  `<h4>question_id: ${qid}</h4>`,
+                  `<pre>${renderRunInfo(aLabel, row?.a, metricKey)}</pre>`,
+                  `<pre>${renderRunInfo(bLabel, row?.b, metricKey)}</pre>`,
+                ].join("");
+              }
+
+              function formatKeyValues(obj) {
+                if (!obj) return "<span class='muted'>n/a</span>";
+                const keys = Object.keys(obj);
+                if (!keys.length) return "<span class='muted'>n/a</span>";
+                return keys.map((k) => `<b>${k}</b>: ${obj[k]}`).join("<br/>");
+              }
+
+              function renderSidebarContent(qid, metricKey, row, parentLabels, metricKeys) {
+                const aLabel = parentLabels.a || "Parent A";
+                const bLabel = parentLabels.b || "Parent B";
+                const a = row?.a;
+                const b = row?.b;
+                const metricList = metricKeys
+                  .map((k) => `<b>${k}</b>: ${a?.metrics?.[k] ?? "n/a"}`)
+                  .join("<br/>");
+                const metricListB = metricKeys
+                  .map((k) => `<b>${k}</b>: ${b?.metrics?.[k] ?? "n/a"}`)
+                  .join("<br/>");
+                const aJson = a ? JSON.stringify(a, null, 2) : "n/a";
+                const bJson = b ? JSON.stringify(b, null, 2) : "n/a";
+                return `
+                  <div class="cols">
+                    <div class="card">
+                      <h4>${aLabel}</h4>
+                      <div class="kv"><b>run_name</b>: ${a?.runName ?? "n/a"}<br/><b>run_id</b>: ${a?.runId ?? "n/a"}</div>
+                      <div class="kv" style="margin-top:6px;"><b>scores</b><br/>${metricList}</div>
+                      <details>
+                        <summary>Params</summary>
+                        <div class="kv">${formatKeyValues(a?.params)}</div>
+                      </details>
+                      <details>
+                        <summary>Raw JSON</summary>
+                        <pre>${aJson}</pre>
+                      </details>
+                    </div>
+                    <div class="card">
+                      <h4>${bLabel}</h4>
+                      <div class="kv"><b>run_name</b>: ${b?.runName ?? "n/a"}<br/><b>run_id</b>: ${b?.runId ?? "n/a"}</div>
+                      <div class="kv" style="margin-top:6px;"><b>scores</b><br/>${metricListB}</div>
+                      <details>
+                        <summary>Params</summary>
+                        <div class="kv">${formatKeyValues(b?.params)}</div>
+                      </details>
+                      <details>
+                        <summary>Raw JSON</summary>
+                        <pre>${bJson}</pre>
+                      </details>
+                    </div>
+                  </div>
+                `;
+              }
+
+              function drawScatter(canvas, points, titleEl, metricKey, colors, runsByQid, parentLabels) {
+                resizeCanvas(canvas, 260);
+                const ctx = canvas.getContext("2d");
+                ctx.clearRect(0, 0, canvas.clientWidth || canvas.width, canvas.clientHeight || canvas.height);
+                titleEl.textContent = metricKey;
+
+                if (!points.length) {
+                  ctx.fillStyle = "#9aa4b2";
+                  ctx.fillText("No data", 16, 20);
+                  return;
+                }
+
+                const padding = { left: 50, right: 20, top: 20, bottom: 40 };
+                const plotWidth = canvas.width - padding.left - padding.right;
+                const plotHeight = canvas.height - padding.top - padding.bottom;
+
+                const isNumeric = points.every((p) => typeof p.qid === "number");
+                let xValues = points.map((p) => p.qid);
+                let xLabelMin = "";
+                let xLabelMax = "";
+                if (!isNumeric) {
+                  const unique = Array.from(new Set(xValues.map(String)));
+                  unique.sort();
+                  const indexByLabel = new Map(unique.map((v, i) => [v, i]));
+                  xValues = points.map((p) => indexByLabel.get(String(p.qid)));
+                  xLabelMin = unique[0] || "";
+                  xLabelMax = unique[unique.length - 1] || "";
+                }
+                const yValues = points.map((p) => p.y);
+                const xMin = Math.min(...xValues);
+                const xMax = Math.max(...xValues);
+                const yMin = Math.min(...yValues);
+                const yMax = Math.max(...yValues);
+                const xRange = xMax - xMin || 1;
+                const yRange = yMax - yMin || 1;
+
+                ctx.strokeStyle = "rgba(255,255,255,0.08)";
+                ctx.lineWidth = 1;
+                for (let i = 0; i <= 5; i++) {
+                  const y = padding.top + (plotHeight * i) / 5;
+                  ctx.beginPath();
+                  ctx.moveTo(padding.left, y);
+                  ctx.lineTo(padding.left + plotWidth, y);
+                  ctx.stroke();
+                }
+
+                ctx.fillStyle = "#9aa4b2";
+                ctx.font = "12px sans-serif";
+                ctx.fillText(isNumeric ? String(xMin) : xLabelMin, padding.left, padding.top + plotHeight + 24);
+                ctx.fillText(isNumeric ? String(xMax) : xLabelMax, padding.left + plotWidth - 60, padding.top + plotHeight + 24);
+                ctx.fillText(String(yMax.toFixed(2)), 8, padding.top + 10);
+                ctx.fillText(String(yMin.toFixed(2)), 8, padding.top + plotHeight);
+
+                const screenPoints = points.map((p, idx) => {
+                  const xVal = isNumeric ? p.qid : xValues[idx];
+                  const x = padding.left + ((xVal - xMin) / xRange) * plotWidth;
+                  const y = padding.top + (1 - (p.y - yMin) / yRange) * plotHeight;
+                  return { ...p, x, y };
+                });
+
+                points.forEach((p, idx) => {
+                  const x = screenPoints[idx].x;
+                  const y = screenPoints[idx].y;
+                  ctx.fillStyle = colors[p.parentKey];
+                  ctx.beginPath();
+                  ctx.arc(x, y, 4, 0, Math.PI * 2);
+                  ctx.fill();
+                });
+
+                const tooltip = document.getElementById("tooltip");
+                const sidebar = document.getElementById("sidebar");
+                const sidebarContent = document.getElementById("sidebarContent");
+                const sidebarTitle = document.getElementById("sidebarTitle");
+                const sidebarClose = document.getElementById("sidebarClose");
+                const sidebarResize = document.getElementById("sidebarResize");
+                let tooltipLocked = false;
+                let lastHoverKey = "";
+                let hideTimer = null;
+                let currentHoverKey = "";
+                const hideTooltip = () => {
+                  if (tooltipLocked || tooltip.matches(":hover")) {
+                    return;
+                  }
+                  tooltip.style.display = "none";
+                  tooltip.scrollTop = 0;
+                  lastHoverKey = "";
+                };
+                sidebarClose.onclick = () => {
+                  sidebar.style.display = "none";
+                };
+                sidebarResize.onmousedown = (evt) => {
+                  evt.preventDefault();
+                  const startX = evt.clientX;
+                  const startWidth = sidebar.getBoundingClientRect().width;
+                  const onMove = (moveEvt) => {
+                    const delta = startX - moveEvt.clientX;
+                    const newWidth = Math.min(
+                      window.innerWidth * 0.9,
+                      Math.max(520, startWidth + delta)
+                    );
+                    sidebar.style.width = `${newWidth}px`;
+                  };
+                  const onUp = () => {
+                    window.removeEventListener("mousemove", onMove);
+                    window.removeEventListener("mouseup", onUp);
+                  };
+                  window.addEventListener("mousemove", onMove);
+                  window.addEventListener("mouseup", onUp);
+                };
+                tooltip.onmouseenter = (evt) => {
+                  evt.stopPropagation();
+                  tooltipLocked = true;
+                  if (hideTimer) {
+                    clearTimeout(hideTimer);
+                    hideTimer = null;
+                  }
+                };
+                tooltip.onmouseleave = () => {
+                  tooltipLocked = false;
+                  hideTimer = window.setTimeout(() => {
+                    hideTooltip();
+                    hideTimer = null;
+                  }, 250);
+                };
+                tooltip.onfocusin = () => {
+                  tooltipLocked = true;
+                  if (hideTimer) {
+                    clearTimeout(hideTimer);
+                    hideTimer = null;
+                  }
+                };
+                tooltip.onfocusout = () => {
+                  tooltipLocked = false;
+                  hideTimer = window.setTimeout(() => {
+                    hideTooltip();
+                    hideTimer = null;
+                  }, 250);
+                };
+                tooltip.onwheel = (evt) => {
+                  evt.preventDefault();
+                  evt.stopPropagation();
+                  tooltip.scrollTop += evt.deltaY;
+                };
+                const hitRadius = 14;
+                canvas.onmousemove = (evt) => {
+                  const rect = canvas.getBoundingClientRect();
+                  const mx = evt.clientX - rect.left;
+                  const my = evt.clientY - rect.top;
+                  let best = null;
+                  let bestDist = hitRadius * hitRadius;
+                  screenPoints.forEach((p) => {
+                    const dx = mx - p.x;
+                    const dy = my - p.y;
+                    const d2 = dx * dx + dy * dy;
+                    if (d2 <= bestDist) {
+                      bestDist = d2;
+                      best = p;
+                    }
+                  });
+                  if (!best) {
+                    // Keep tooltip visible while moving off the point to allow entering tooltip.
+                    return;
+                  }
+                  if (tooltipLocked) {
+                    return;
+                  }
+                  const hoverKey = `${best.qid}:${metricKey}`;
+                  currentHoverKey = hoverKey;
+                  if (hoverKey !== lastHoverKey) {
+                    const row = runsByQid.get(String(best.qid));
+                    tooltip.innerHTML = renderTooltipContent(best.qid, metricKey, row, parentLabels);
+                    tooltip.style.display = "block";
+                    const anchorX = rect.left + best.x;
+                    const anchorY = rect.top + best.y;
+                    tooltip.style.left = `${anchorX + 12}px`;
+                    tooltip.style.top = `${anchorY + 12}px`;
+                    tooltip.tabIndex = 0;
+                    tooltip.focus({ preventScroll: true });
+                    lastHoverKey = hoverKey;
+                    if (hideTimer) {
+                      clearTimeout(hideTimer);
+                      hideTimer = null;
+                    }
+                  }
+                };
+                canvas.onmouseleave = () => {
+                  if (!tooltipLocked && !hideTimer) {
+                    hideTimer = window.setTimeout(() => {
+                      hideTooltip();
+                      hideTimer = null;
+                    }, 600);
+                  }
+                };
+                canvas.onclick = (evt) => {
+                  const rect = canvas.getBoundingClientRect();
+                  const mx = evt.clientX - rect.left;
+                  const my = evt.clientY - rect.top;
+                  let best = null;
+                  let bestDist = hitRadius * hitRadius;
+                  screenPoints.forEach((p) => {
+                    const dx = mx - p.x;
+                    const dy = my - p.y;
+                    const d2 = dx * dx + dy * dy;
+                    if (d2 <= bestDist) {
+                      bestDist = d2;
+                      best = p;
+                    }
+                  });
+                  if (!best) return;
+                  const row = runsByQid.get(String(best.qid));
+                  sidebarTitle.textContent = `question_id: ${best.qid} (${metricKey})`;
+                  sidebarContent.innerHTML = renderSidebarContent(
+                    best.qid,
+                    metricKey,
+                    row,
+                    parentLabels,
+                    window.__metricKeys || [metricKey]
+                  );
+                  sidebar.style.display = "block";
+                };
+              }
+
+              function renderTable(rows, metricKeys) {
+                const tbody = document.querySelector("#resultsTable tbody");
+                tbody.innerHTML = "";
+                const sorted = Array.from(rows.keys()).sort((a, b) => Number(a) - Number(b));
+                sorted.forEach((qid) => {
+                  const row = rows.get(qid);
+                  const tr = document.createElement("tr");
+                  tr.innerHTML = `
+                    <td>${qid}</td>
+                    <td>${row.a ? row.a.runName : "<span class='muted'>n/a</span>"}</td>
+                    <td>${row.a ? metricKeys.map((k) => `${k}: ${row.a.metrics[k] ?? "n/a"}`).join("<br/>") : "<span class='muted'>n/a</span>"}</td>
+                    <td>${row.b ? row.b.runName : "<span class='muted'>n/a</span>"}</td>
+                    <td>${row.b ? metricKeys.map((k) => `${k}: ${row.b.metrics[k] ?? "n/a"}`).join("<br/>") : "<span class='muted'>n/a</span>"}</td>
+                  `;
+                  tbody.appendChild(tr);
+                });
+              }
+
+              async function loadData() {
+                updateUrlFromInputs();
+                const experimentId = document.getElementById("experimentId").value.trim();
+                let parentA = document.getElementById("parentA").value.trim();
+                let parentB = document.getElementById("parentB").value.trim();
+                const metric1 = document.getElementById("metric1").value.trim();
+                const metric2 = document.getElementById("metric2").value.trim();
+                const metric3 = document.getElementById("metric3").value.trim();
+
+                if (!experimentId || !parentA || !parentB) {
+                  return;
+                }
+
+                if (parentA.length < 20) {
+                  parentA = await resolveParentRunId(experimentId, parentA);
+                }
+                if (parentB.length < 20) {
+                  parentB = await resolveParentRunId(experimentId, parentB);
+                }
+                if (!parentA || !parentB) {
+                  return;
+                }
+
+                const [parentARun, parentBRun] = await Promise.all([
+                  getRunById(experimentId, parentA),
+                  getRunById(experimentId, parentB),
+                ]);
+                const parentALabel = parentARun?.info?.run_name || parentA;
+                const parentBLabel = parentBRun?.info?.run_name || parentB;
+                document.getElementById("legendA").textContent = parentALabel;
+                document.getElementById("legendB").textContent = parentBLabel;
+
+                const [runsA, runsB] = await Promise.all([
+                  searchRuns(experimentId, parentA),
+                  searchRuns(experimentId, parentB),
+                ]);
+
+                const parsedA = runsA.map(parseRun);
+                const parsedB = runsB.map(parseRun);
+
+                const rows = new Map();
+                function upsert(run, key) {
+                  const qid = run.params.question_id;
+                  if (!qid) return;
+                  if (!rows.has(qid)) rows.set(qid, {});
+                  rows.get(qid)[key] = run;
+                }
+                parsedA.forEach((r) => upsert(r, "a"));
+                parsedB.forEach((r) => upsert(r, "b"));
+                renderTable(rows, [metric1, metric2, metric3]);
+
+                const points1 = buildPoints(parsedA, "a", metric1).concat(buildPoints(parsedB, "b", metric1));
+                const points2 = buildPoints(parsedA, "a", metric2).concat(buildPoints(parsedB, "b", metric2));
+                const points3 = buildPoints(parsedA, "a", metric3).concat(buildPoints(parsedB, "b", metric3));
+
+                const colors = { a: getComputedStyle(document.documentElement).getPropertyValue("--accent-a").trim(), b: getComputedStyle(document.documentElement).getPropertyValue("--accent-b").trim() };
+                const parentLabels = { a: parentALabel, b: parentBLabel };
+                window.__metricKeys = [metric1, metric2, metric3];
+                drawScatter(document.getElementById("plot1"), points1, document.getElementById("plotTitle1"), metric1, colors, rows, parentLabels);
+                drawScatter(document.getElementById("plot2"), points2, document.getElementById("plotTitle2"), metric2, colors, rows, parentLabels);
+                drawScatter(document.getElementById("plot3"), points3, document.getElementById("plotTitle3"), metric3, colors, rows, parentLabels);
+              }
+
+              document.getElementById("loadBtn").addEventListener("click", loadData);
+              setInputsFromUrl();
+              loadData();
+            </script>
+          </body>
+        </html>
+        """
+    )
+    return Response(html, mimetype="text/html")
+
+
+# We expect the react app to be built assuming it is hosted at /static-files, so that requests for
+# CSS/JS resources will be made to e.g. /static-files/main.css and we can handle them here.
+# The files are hashed based on source code, so ok to send Cache-Control headers via max_age.
+@app.route(_add_static_prefix("/static-files/<path:path>"))
+def serve_static_file(path):
+    if IS_FLASK_V1:
+        return send_from_directory(app.static_folder, path, cache_timeout=2419200)
+    else:
+        return send_from_directory(app.static_folder, path, max_age=2419200)
+
+
+# Serve the index.html for the React App for all other routes.
+@app.route(_add_static_prefix("/"))
+def serve():
+    if os.path.exists(os.path.join(app.static_folder, "index.html")):
+        return send_from_directory(app.static_folder, "index.html")
+
+    text = textwrap.dedent(
+        """
+    Unable to display MLflow UI - landing page (index.html) not found.
+
+    You are very likely running the MLflow server using a source installation of the Python MLflow
+    package.
+
+    If you are a developer making MLflow source code changes and intentionally running a source
+    installation of MLflow, you can view the UI by running the Javascript dev server:
+    https://github.com/mlflow/mlflow/blob/master/CONTRIBUTING.md#running-the-javascript-dev-server
+
+    Otherwise, uninstall MLflow via 'pip uninstall mlflow', reinstall an official MLflow release
+    from PyPI via 'pip install mlflow', and rerun the MLflow server.
+    """
+    )
+    return Response(text, mimetype="text/plain")
+
+
+def _find_app(app_name: str) -> str:
+    apps = get_entry_points("mlflow.app")
+    for app in apps:
+        if app.name == app_name:
+            return app.value
+
+    raise MlflowException(
+        f"Failed to find app '{app_name}'. Available apps: {[a.name for a in apps]}"
+    )
+
+
+def _is_factory(app: str) -> bool:
+    """
+    Returns True if the given app is a factory function, False otherwise.
+
+    Args:
+        app: The app to check, e.g. "mlflow.server.app:app
+    """
+    module, obj_name = app.rsplit(":", 1)
+    mod = importlib.import_module(module)
+    obj = getattr(mod, obj_name)
+    return isinstance(obj, types.FunctionType)
+
+
+def get_app_client(app_name: str, *args, **kwargs):
+    """
+    Instantiate a client provided by an app.
+
+    Args:
+        app_name: The app name defined in `setup.py`, e.g., "basic-auth".
+        args: Additional arguments passed to the app client constructor.
+        kwargs: Additional keyword arguments passed to the app client constructor.
+
+    Returns:
+        An app client instance.
+    """
+    clients = get_entry_points("mlflow.app.client")
+    for client in clients:
+        if client.name == app_name:
+            cls = client.load()
+            return cls(*args, **kwargs)
+
+    raise MlflowException(
+        f"Failed to find client for '{app_name}'. Available clients: {[c.name for c in clients]}"
+    )
+
+
+def _build_waitress_command(waitress_opts, host, port, app_name, is_factory):
+    opts = shlex.split(waitress_opts) if waitress_opts else []
+    return [
+        sys.executable,
+        "-m",
+        "waitress",
+        *opts,
+        f"--host={host}",
+        f"--port={port}",
+        "--ident=mlflow",
+        *(["--call"] if is_factory else []),
+        app_name,
+    ]
+
+
+def _build_gunicorn_command(gunicorn_opts, host, port, workers, app_name):
+    bind_address = f"{host}:{port}"
+    opts = shlex.split(gunicorn_opts) if gunicorn_opts else []
+    return [
+        sys.executable,
+        "-m",
+        "gunicorn",
+        *opts,
+        "-b",
+        bind_address,
+        "-w",
+        str(workers),
+        app_name,
+    ]
+
+
+def _build_uvicorn_command(uvicorn_opts, host, port, workers, app_name, env_file=None):
+    """Build command to run uvicorn server."""
+    opts = shlex.split(uvicorn_opts) if uvicorn_opts else []
+    cmd = [
+        sys.executable,
+        "-m",
+        "uvicorn",
+        *opts,
+        "--host",
+        host,
+        "--port",
+        str(port),
+        "--workers",
+        str(workers),
+    ]
+    if env_file:
+        cmd.extend(["--env-file", env_file])
+    cmd.append(app_name)
+    return cmd
+
+
+def _run_server(
+    *,
+    file_store_path,
+    registry_store_uri,
+    default_artifact_root,
+    serve_artifacts,
+    artifacts_only,
+    artifacts_destination,
+    host,
+    port,
+    static_prefix=None,
+    workers=None,
+    gunicorn_opts=None,
+    waitress_opts=None,
+    expose_prometheus=None,
+    app_name=None,
+    uvicorn_opts=None,
+    env_file=None,
+    secrets_cache_ttl=None,
+    secrets_cache_max_size=None,
+):
+    """
+    Run the MLflow server, wrapping it in gunicorn, uvicorn, or waitress on windows
+
+    Args:
+        static_prefix: If set, the index.html asset will be served from the path static_prefix.
+                       If left None, the index.html asset will be served from the root path.
+        uvicorn_opts: Additional options for uvicorn server.
+
+    Returns:
+        None
+    """
+    env_map = {}
+    if file_store_path:
+        env_map[BACKEND_STORE_URI_ENV_VAR] = file_store_path
+    if registry_store_uri:
+        env_map[REGISTRY_STORE_URI_ENV_VAR] = registry_store_uri
+    if default_artifact_root:
+        env_map[ARTIFACT_ROOT_ENV_VAR] = default_artifact_root
+    if serve_artifacts:
+        env_map[SERVE_ARTIFACTS_ENV_VAR] = "true"
+    if artifacts_only:
+        env_map[ARTIFACTS_ONLY_ENV_VAR] = "true"
+    if artifacts_destination:
+        env_map[ARTIFACTS_DESTINATION_ENV_VAR] = artifacts_destination
+    if static_prefix:
+        env_map[STATIC_PREFIX_ENV_VAR] = static_prefix
+
+    if expose_prometheus:
+        env_map[PROMETHEUS_EXPORTER_ENV_VAR] = expose_prometheus
+
+    if secrets_cache_ttl is not None:
+        env_map[SECRETS_CACHE_TTL_ENV_VAR] = str(secrets_cache_ttl)
+    if secrets_cache_max_size is not None:
+        env_map[SECRETS_CACHE_MAX_SIZE_ENV_VAR] = str(secrets_cache_max_size)
+
+    if secret_key := MLFLOW_FLASK_SERVER_SECRET_KEY.get():
+        env_map[MLFLOW_FLASK_SERVER_SECRET_KEY.name] = secret_key
+
+    # Determine which server we're using (only one should be true)
+    using_gunicorn = gunicorn_opts is not None
+    using_waitress = waitress_opts is not None
+    using_uvicorn = not using_gunicorn and not using_waitress
+
+    if using_uvicorn:
+        env_map[_MLFLOW_SGI_NAME.name] = "uvicorn"
+    elif using_waitress:
+        env_map[_MLFLOW_SGI_NAME.name] = "waitress"
+    elif using_gunicorn:
+        env_map[_MLFLOW_SGI_NAME.name] = "gunicorn"
+
+    if app_name is None:
+        is_factory = False
+        # For uvicorn, use the FastAPI app; for gunicorn/waitress, use the Flask app
+        app = "mlflow.server.fastapi_app:app" if using_uvicorn else f"{__name__}:app"
+    else:
+        app = _find_app(app_name)
+        is_factory = _is_factory(app)
+        # `waitress` doesn't support `()` syntax for factory functions.
+        # Instead, we need to use the `--call` flag.
+        # Don't use () syntax if we're using uvicorn
+        use_factory_syntax = not is_windows() and is_factory and not using_uvicorn
+        app = f"{app}()" if use_factory_syntax else app
+
+    # Determine which server to use
+    if using_uvicorn:
+        # Use uvicorn (default when no specific server options are provided)
+        full_command = _build_uvicorn_command(uvicorn_opts, host, port, workers or 4, app, env_file)
+    elif using_waitress:
+        # Use waitress if explicitly requested
+        warnings.warn(
+            "We recommend using uvicorn for improved performance. "
+            "Please use uvicorn by default or specify '--uvicorn-opts' "
+            "instead of '--waitress-opts'.",
+            FutureWarning,
+            stacklevel=2,
+        )
+        full_command = _build_waitress_command(waitress_opts, host, port, app, is_factory)
+    elif using_gunicorn:
+        # Use gunicorn if explicitly requested
+        if sys.platform == "win32":
+            raise MlflowException(
+                "Gunicorn is not supported on Windows. "
+                "Please use uvicorn (default) or specify '--waitress-opts'."
+            )
+        warnings.warn(
+            "We recommend using uvicorn for improved performance. "
+            "Please use uvicorn by default or specify '--uvicorn-opts' "
+            "instead of '--gunicorn-opts'.",
+            FutureWarning,
+            stacklevel=2,
+        )
+        full_command = _build_gunicorn_command(gunicorn_opts, host, port, workers or 4, app)
+    else:
+        # This shouldn't happen given the logic in CLI, but handle it just in case
+        raise MlflowException("No server configuration specified.")
+
+    if MLFLOW_SERVER_ENABLE_JOB_EXECUTION.get():
+        # The `HUEY_STORAGE_PATH_ENV_VAR` is used by both MLflow server handler workers and
+        # huey job runner (huey_consumer).
+        env_map[HUEY_STORAGE_PATH_ENV_VAR] = (
+            tempfile.mkdtemp(dir="/dev/shm")  # Use in-memory file system if possible
+            if os.path.exists("/dev/shm")
+            else tempfile.mkdtemp()
+        )
+
+    if MLFLOW_SERVER_ENABLE_JOB_EXECUTION.get():
+        from mlflow.server.jobs.utils import _check_requirements
+
+        try:
+            _check_requirements(file_store_path)
+        except Exception as e:
+            raise MlflowException(
+                f"MLflow job runner requirements checking failed (root error: {e!s}). "
+                "If you don't need MLflow job runner, you can disable it by setting "
+                "environment variable 'MLFLOW_SERVER_ENABLE_JOB_EXECUTION' to 'false'."
+            )
+
+    server_proc = _exec_cmd(
+        full_command, extra_env=env_map, capture_output=False, synchronous=False
+    )
+
+    if MLFLOW_SERVER_ENABLE_JOB_EXECUTION.get():
+        from mlflow.environment_variables import MLFLOW_TRACKING_URI
+        from mlflow.server.jobs.utils import _launch_job_runner
+
+        _launch_job_runner(
+            {
+                **env_map,
+                # Set tracking URI environment variable for job runner
+                # so that all job processes inherits it.
+                MLFLOW_TRACKING_URI.name: f"http://{host}:{port}",
+            },
+            server_proc.pid,
+        )
+
+    server_proc.wait()
